//! Analog-to-Digital Converter (IADC) Driver
//!
//! This module provides ADC functionality using the IADC0 peripheral
//! for the EFR32MG24 microcontroller.
//!
//! # Hardware Registers
//!
//! - **EN**: Enable register
//! - **CTRL**: Control register
//! - **CMD**: Command register (start conversion)
//! - **STATUS**: Status flags
//! - **CFG0**: Configuration register for single conversion
//! - **SINGLE**: Single conversion configuration
//! - **SINGLEFIFODATA**: Single conversion result
//! - **IF/IEN**: Interrupt flags and enable
//!
//! # Features
//!
//! - Single-shot ADC conversion
//! - Configurable resolution (12-bit)
//! - Multiple reference voltage sources (VBGR, VDD)
//! - Timeout-protected conversion
//! - Critical section protection for RTOS safety
//!
//! # Example
//!
//! ```no_run
//! use efr32mg24_hal::{
//!     clock::{Clocks, ClockConfig, HfxoConfig},
//!     adc::{Adc, Config, Channel, Reference},
//!     pac,
//! };
//!
//! let dp = pac::Peripherals::take().unwrap();
//!
//! // Configure clocks
//! let clocks = Clocks::new(dp.cmu_s, ClockConfig {
//!     hfxo: Some(HfxoConfig::new(39_000_000)),
//!     lfxo: Some(Default::default()),
//! }).freeze();
//!
//! // Create ADC with default configuration (12-bit, VBGR reference)
//! let mut adc = Adc::new(dp.iadc0_s, Config::default(), &clocks);
//!
//! // Read from channel 0
//! let value = adc.read(Channel::Ch0).unwrap();
//! ```

mod traits;
mod types;

pub use types::{Channel, Config, Error, Reference, Resolution};

use crate::clock::FrozenClocks;
use crate::pac;

/// ADC instance
pub struct Adc {
    adc: pac::Iadc0S,
    reference: Reference,
}

impl Adc {
    /// Creates a new ADC instance
    ///
    /// # Arguments
    ///
    /// * `adc` - IADC peripheral instance
    /// * `config` - ADC configuration
    /// * `clocks` - Frozen clock configuration
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use efr32mg24_hal::{adc::{Adc, Config}, clock::{Clocks, ClockConfig, HfxoConfig}, pac};
    /// # let dp = pac::Peripherals::take().unwrap();
    /// # let clocks = Clocks::new(dp.cmu_s, ClockConfig {
    /// #     hfxo: Some(HfxoConfig::new(39_000_000)),
    /// #     lfxo: Some(Default::default()),
    /// # }).freeze();
    /// let adc = Adc::new(dp.iadc0_s, Config::default(), &clocks);
    /// ```
    pub fn new(adc: pac::Iadc0S, config: Config, clocks: &FrozenClocks) -> Self {
        // Enable IADC clock using safe accessor with critical section
        clocks.enable_peripheral_clock(|cmu| {
            cmu.clken0().modify(|_, w| w.iadc0().set_bit());
        });

        // Enable IADC peripheral
        // SAFETY: Writing to EN register to enable the peripheral is always safe.
        // This is a write-only operation that enables the IADC hardware module.
        adc.en().write(|w| w.en().set_bit());

        // Configure reference voltage
        // SAFETY: CTRL register configuration is type-safe. The warmupmode field
        // accepts enum variants that are validated by svd2rust generation.
        adc.ctrl().write(|w| {
            w.warmupmode().normal() // Normal reference warmup
        });

        // Configure ADC for single conversion mode
        // SAFETY: CFG0 register fields are type-safe enum variants generated by svd2rust.
        // Reference selection (vbgr/vdd) is hardware-validated through the PAC API.
        adc.cfg0().write(|w| match config.reference {
            Reference::Vbgr => w.adcmode().normal().refsel().vbgr(),
            Reference::Vdd => w.adcmode().normal().refsel().vddx(),
        });

        Self {
            adc,
            reference: config.reference,
        }
    }

    /// Perform a single ADC conversion on the specified channel
    ///
    /// This function configures the channel, starts the conversion, waits for
    /// completion (with timeout), and returns the result.
    ///
    /// # Arguments
    ///
    /// * `channel` - ADC channel to read from
    ///
    /// # Returns
    ///
    /// `Ok(u16)` with the conversion result (12-bit value 0-4095)
    /// `Err(Error)` if the conversion times out
    ///
    /// # Thread Safety
    ///
    /// This function uses critical sections for atomic register access,
    /// making it safe to call from interrupt contexts or RTOS tasks.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use efr32mg24_hal::{adc::{Adc, Config, Channel}, clock::{Clocks, ClockConfig, HfxoConfig}, pac};
    /// # let dp = pac::Peripherals::take().unwrap();
    /// # let clocks = Clocks::new(dp.cmu_s, ClockConfig {
    /// #     hfxo: Some(HfxoConfig::new(39_000_000)),
    /// #     lfxo: Some(Default::default()),
    /// # }).freeze();
    /// # let mut adc = Adc::new(dp.iadc0_s, Config::default(), &clocks);
    /// let value = adc.read(Channel::Ch0).unwrap();
    /// ```
    pub fn read(&mut self, channel: Channel) -> Result<u16, Error> {
        // Configure single conversion for the selected channel
        // Use critical section for atomic configuration
        critical_section::with(|_cs| {
            // SAFETY: SINGLE register configuration is type-safe. The portpos/pinpos and
            // portneg/pinneg fields are validated by the Channel enum which only contains
            // hardware-valid values. For single-ended mode, positive = channel, negative = GND.
            self.adc.single().write(|w| unsafe {
                w.portpos().bits(8) // Port A (value 8)
                    .pinpos().bits(channel as u8) // Positive pin = channel
                    .portneg().bits(0) // Ground (single-ended)
                    .pinneg().bits(0) // Pin 0 (ignored for GND)
            });
        });

        // Start single conversion
        // SAFETY: Writing to CMD register's singlestart bit is a write-only operation
        // that triggers the ADC conversion. This is the standard hardware operation.
        self.adc.cmd().write(|w| w.singlestart().set_bit());

        // Wait for conversion to complete with timeout
        // Timeout prevents infinite loop if hardware fails
        const TIMEOUT_CYCLES: u32 = 100_000; // ~1ms at 78 MHz
        let mut timeout = 0;

        while self.adc.status().read().singlefifodv().bit_is_clear() {
            timeout += 1;
            if timeout >= TIMEOUT_CYCLES {
                return Err(Error::Timeout);
            }
        }

        // Read conversion result
        // SAFETY: Reading from SINGLEFIFODATA is always safe. The hardware ensures
        // valid data is present when SINGLEFIFODV flag is set (checked above).
        let result = self.adc.singlefifodata().read().data().bits();

        // Return 12-bit result (mask to ensure 12-bit range, convert u32 to u16)
        Ok((result & 0x0FFF) as u16)
    }

    /// Get the configured reference voltage source
    pub fn reference(&self) -> Reference {
        self.reference
    }

    /// Disable the ADC peripheral
    ///
    /// This disables the IADC hardware module to save power.
    pub fn disable(self) {
        // SAFETY: Writing to EN register to disable the peripheral is always safe.
        // This is a write-only operation that disables the IADC hardware module.
        self.adc.en().write(|w| w.en().clear_bit());
    }
}
